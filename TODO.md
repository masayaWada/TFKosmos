# TFKosmos TODOリスト

---

## 📊 テスト実装計画（完了サマリー）

### ✅ Phase 1 & 2: 完了済み

#### バックエンドテスト（完了）
- [x] AWS/Azureスキャナー: 31テスト実装完了
  - [x] AWS scanner: 16テスト（`IamClientOps`トレイト導入）
  - [x] Azure scanner: 15テスト（`AzureClientOps`トレイト導入）
- [x] Terraform生成サービス: 35テスト実装完了
  - [x] generation_service: 15テスト
  - [x] terraform generator: 20テスト
- [x] テンプレート管理: 16テスト実装完了
  - [x] template manager: 7テスト
  - [x] template service: 9テスト
- [x] API統合テスト: 完了
  - [x] connection, scan, generate, templates エンドポイント

#### フロントエンドテスト（完了）
- [x] 状態管理: 42テスト実装完了（AppContext）
- [x] APIクライアント: 47テスト実装完了
  - [x] connection.ts: 11テスト
  - [x] scan.ts: 18テスト
  - [x] resources.ts: 18テスト
- [x] コンポーネント: 124テスト実装完了
  - [x] AwsConnectionForm: 18テスト
  - [x] AzureConnectionForm: 21テスト
  - [x] ScanConfigForm: 23テスト
  - [x] ResourceTable: 23テスト
  - [x] QueryInput: 24テスト
  - [x] TemplatesPage: 15テスト
- [x] ページコンポーネント: 42テスト実装完了
  - [x] ResourcesPage: 22テスト
  - [x] GeneratePage: 20テスト
- [x] テンプレートAPI: 28テスト実装完了
  - [x] templates.ts: 18テスト
  - [x] templates.rs API: 10テスト

**合計**: バックエンド 82テスト、フロントエンド 283テスト

---

## 🚀 Phase 3: E2E & テストインフラ

### E2Eテスト環境構築

#### Playwrightセットアップ
- [x] Playwrightのインストール
  ```bash
  cd frontend
  npm install -D @playwright/test
  npx playwright install
  ```

- [x] `playwright.config.ts` の作成
  - [x] ベースURL設定（http://localhost:5173）
  - [x] ブラウザ設定（chromium, firefox, webkit）
  - [x] タイムアウト設定
  - [x] スクリーンショット設定

- [x] `frontend/e2e/` ディレクトリ構造の作成
  ```
  frontend/e2e/
  ├── fixtures/          # テストデータ
  ├── pages/             # Page Objectパターン
  └── tests/             # テストケース
  ```

#### 基本E2Eテストの実装
- [x] 接続テストフロー
  - [x] AWS接続画面の表示
  - [x] 認証情報入力
  - [x] 接続テスト実行（スキップ: 実際の認証情報が必要）
  - [x] 成功/失敗メッセージの確認

- [x] スキャンフロー
  - [x] スキャン設定画面の表示
  - [x] プロバイダー選択
  - [x] スキャン実行（スキップ: 実際のバックエンドが必要）
  - [x] 進捗表示の確認
  - [x] 結果画面への遷移

### テストインフラの改善

#### カバレッジ測定
- [ ] バックエンド: `tarpaulin` または `cargo-llvm-cov` の導入
  ```bash
  cargo install cargo-tarpaulin
  cargo tarpaulin --out Html
  ```

- [ ] フロントエンド: Vitestカバレッジ設定の最適化
  ```bash
  npm run test:coverage
  ```

- [ ] カバレッジレポートの生成
  - [ ] HTML形式のレポート
  - [ ] CI/CD統合
  - [ ] カバレッジバッジの追加

#### CI/CDパイプライン
- [ ] GitHub Actionsワークフローの作成
  - [ ] バックエンドテストの自動実行
  - [ ] フロントエンドテストの自動実行
  - [ ] E2Eテストの自動実行
  - [ ] カバレッジレポートの生成とアップロード

- [ ] テスト実行の最適化
  - [ ] 並列実行の設定
  - [ ] キャッシュの活用
  - [ ] テスト分割

#### テストデータ管理
- [x] フィクスチャの整備
  - [ ] バックエンド: テストデータJSON
  - [ ] フロントエンド: モックデータ
  - [x] E2E: シードデータ

- [x] テストヘルパーの作成
  - [ ] バックエンド: モックビルダー
  - [ ] フロントエンド: カスタムレンダラー
  - [x] E2E: Page Objectパターン

### 完全なE2Eテストスイート

#### エンドツーエンドシナリオ
- [ ] AWS完全フロー
  - [ ] AWS接続 → スキャン → リソース選択 → Terraform生成 → ダウンロード

- [ ] Azure完全フロー
  - [ ] Azure接続 → スキャン → リソース選択 → Terraform生成 → ダウンロード

- [ ] テンプレートカスタマイズフロー
  - [ ] テンプレート編集 → 検証 → 保存 → Terraform生成

#### エッジケースとエラーシナリオ
- [ ] 認証エラーのテスト
- [ ] ネットワークエラーのテスト
- [ ] タイムアウトのテスト
- [ ] 不正な入力のテスト
- [ ] 大量データの処理テスト

### パフォーマンステスト
- [ ] ロードテストの実装
  - [ ] 大量リソースのスキャン
  - [ ] 並行スキャンの処理
  - [ ] 大量リソースのTerraform生成

- [ ] ベンチマークの作成
  - [ ] バックエンド: `criterion` の使用
  - [ ] フロントエンド: Lighthouse CI

---

## 🎯 Phase 4: 機能追加計画

### クラウドプロバイダー拡張

#### GCPサポート
- [ ] GCP認証機能の実装
  - [ ] サービスアカウント認証
  - [ ] Application Default Credentials
  - [ ] 接続テスト機能

- [ ] GCP IAMスキャナーの実装
  - [ ] サービスアカウント取得
  - [ ] IAMロール取得
  - [ ] IAMポリシー取得
  - [ ] プロジェクト情報取得

- [ ] GCP Terraformジェネレーター
  - [ ] google_service_account リソース
  - [ ] google_project_iam_* リソース
  - [ ] インポートスクリプト生成
  - [ ] テンプレート作成

- [ ] GCP統合テスト
  - [ ] スキャナーのテスト
  - [ ] ジェネレーターのテスト
  - [ ] E2Eテスト

### リソースタイプ拡張

#### AWSリソース追加
- [ ] EC2インスタンス
  - [ ] スキャン機能
  - [ ] Terraform生成
  - [ ] インポート対応

- [ ] VPCリソース
  - [ ] VPC、サブネット
  - [ ] ルートテーブル
  - [ ] セキュリティグループ
  - [ ] NACLs

- [ ] RDS
  - [ ] DBインスタンス
  - [ ] DBサブネットグループ
  - [ ] パラメータグループ

- [ ] S3
  - [ ] バケット
  - [ ] バケットポリシー
  - [ ] ライフサイクル設定

#### Azureリソース追加
- [ ] 仮想マシン
- [ ] 仮想ネットワーク
- [ ] ストレージアカウント
- [ ] SQLデータベース

### 高度な機能

#### 差分検出機能
- [ ] 既存Terraformコードの読み込み
- [ ] スキャン結果との差分比較
- [ ] 差分レポート生成
- [ ] 差分の可視化（UI）

#### 設定管理
- [ ] スキャン設定のインポート/エクスポート
  - [ ] JSON/YAML形式での保存
  - [ ] 設定テンプレート
  - [ ] 設定の共有

- [ ] プロジェクト管理
  - [ ] 複数プロジェクトの管理
  - [ ] プロジェクト間の切り替え
  - [ ] プロジェクト設定の永続化

#### バッチ処理
- [ ] 複数アカウント/サブスクリプションの一括スキャン
- [ ] スケジュールスキャン
- [ ] バッチレポート生成

#### CLIサポート
- [ ] コマンドラインインターフェースの実装
  - [ ] `tfkosmos scan` コマンド
  - [ ] `tfkosmos generate` コマンド
  - [ ] 設定ファイルサポート
  - [ ] パイプライン統合

#### Terraform統合
- [ ] Terraform Cloud統合
  - [ ] ワークスペース連携
  - [ ] State管理
  - [ ] リモート実行

- [ ] Terraform Enterprise統合
  - [ ] 組織管理
  - [ ] チーム権限

### UI/UX改善

#### ダッシュボード
- [ ] スキャン履歴の表示
- [ ] リソース統計の可視化
- [ ] 最近のアクティビティ

#### 検索・フィルタ機能強化
- [ ] 高度な検索クエリ
- [ ] 保存された検索条件
- [ ] タグベースのフィルタリング

#### エクスポート機能
- [ ] CSVエクスポート
- [ ] JSONエクスポート
- [ ] レポート生成（PDF）

---

## 🔧 Phase 5: 全体レビュー&リファクタリング計画

### コードベース全体レビュー

#### アーキテクチャレビュー
- [ ] 現在のアーキテクチャの文書化
  - [ ] システム構成図の作成
  - [ ] データフロー図の作成
  - [ ] アーキテクチャ決定記録（ADR）の作成

- [ ] アーキテクチャの評価
  - [ ] スケーラビリティの検証
  - [ ] 保守性の評価
  - [ ] 拡張性の確認

- [ ] 改善提案の作成
  - [ ] ボトルネックの特定
  - [ ] 改善案の文書化
  - [ ] 優先順位付け

#### コード品質レビュー
- [ ] バックエンド（Rust）
  - [ ] Clippyによる静的解析
  - [ ] コーディング規約の準拠確認
  - [ ] 未使用コードの削除
  - [ ] ドキュメントコメントの充実

- [ ] フロントエンド（TypeScript/React）
  - [ ] ESLintによる静的解析
  - [ ] 型安全性の向上
  - [ ] コンポーネント設計のレビュー
  - [ ] アクセシビリティの改善

### パフォーマンス最適化

#### バックエンド最適化
- [ ] スキャン処理の高速化
  - [ ] 並列処理の最適化
  - [ ] キャッシング戦略の見直し
  - [ ] 不要なAPI呼び出しの削減

- [ ] Terraform生成の最適化
  - [ ] テンプレートレンダリングの高速化
  - [ ] ファイルI/Oの最適化
  - [ ] メモリ使用量の削減

- [ ] API応答時間の改善
  - [ ] レスポンスのストリーミング
  - [ ] 非同期処理の活用
  - [ ] データベースクエリの最適化（将来的に導入する場合）

#### フロントエンド最適化
- [ ] バンドルサイズの削減
  - [ ] コード分割の実装
  - [ ] 遅延ロード（Lazy loading）
  - [ ] Tree shaking の最適化

- [ ] レンダリングパフォーマンス
  - [ ] React.memoの活用
  - [ ] useCallbackの適切な使用
  - [ ] 仮想スクロールの導入（大量データ表示時）

- [ ] ネットワーク最適化
  - [ ] APIリクエストのバッチング
  - [ ] キャッシング戦略
  - [ ] Progressive Web App（PWA）対応

### エラーハンドリングとログ強化

#### エラーハンドリング改善
- [ ] バックエンド
  - [ ] エラー型の統一化
  - [ ] コンテキスト情報の充実
  - [ ] リトライロジックの実装
  - [ ] グレースフルデグラデーション

- [ ] フロントエンド
  - [ ] エラーバウンダリの実装
  - [ ] ユーザーフレンドリーなエラーメッセージ
  - [ ] エラー復旧機能
  - [ ] オフライン対応

#### ログ機能の強化
- [ ] 構造化ログの導入
  - [ ] JSON形式のログ出力
  - [ ] ログレベルの適切な使い分け
  - [ ] コンテキスト情報の付加

- [ ] ログ管理
  - [ ] ログローテーション
  - [ ] ログの集約（将来的に）
  - [ ] ログ分析ツールの導入検討

- [ ] モニタリング
  - [ ] メトリクス収集
  - [ ] アラート設定
  - [ ] ダッシュボード作成

### セキュリティ監査

#### セキュリティレビュー
- [ ] 認証・認証情報管理
  - [ ] 認証情報の安全な保存方法の再検討
  - [ ] セッション管理の改善
  - [ ] トークンの有効期限管理

- [ ] 入力バリデーション
  - [ ] すべての入力ポイントのバリデーション
  - [ ] SQLインジェクション対策（将来的にDB導入時）
  - [ ] XSS対策の確認

- [ ] 依存関係の監査
  - [ ] 脆弱性スキャン（npm audit, cargo audit）
  - [ ] 定期的な依存関係の更新
  - [ ] ライセンスコンプライアンスの確認

#### セキュリティ機能追加
- [ ] レート制限の実装
- [ ] CORS設定の見直し
- [ ] Content Security Policy（CSP）の実装
- [ ] セキュリティヘッダーの追加

### ドキュメント整備

#### ユーザードキュメント
- [ ] ユーザーガイドの作成
  - [ ] インストール手順
  - [ ] 基本的な使い方
  - [ ] トラブルシューティング
  - [ ] FAQ

- [ ] チュートリアル
  - [ ] AWS IAMのスキャンと生成
  - [ ] Azure IAMのスキャンと生成
  - [ ] カスタムテンプレートの作成

- [ ] API ドキュメント
  - [ ] OpenAPI仕様書の作成
  - [ ] エンドポイント一覧
  - [ ] リクエスト/レスポンス例

#### 開発者ドキュメント
- [ ] コントリビューションガイド
  - [ ] 開発環境のセットアップ
  - [ ] コーディング規約
  - [ ] プルリクエストのガイドライン

- [ ] アーキテクチャドキュメント
  - [ ] システム設計の詳細
  - [ ] データモデル
  - [ ] API設計

- [ ] デプロイガイド
  - [ ] ビルド手順
  - [ ] リリースプロセス
  - [ ] 環境設定

### 技術的負債の解消

#### リファクタリング優先リスト
- [ ] 重複コードの削除
  - [ ] 共通処理の抽出
  - [ ] ユーティリティ関数の整理
  - [ ] コンポーネントの再利用性向上

- [ ] 命名の改善
  - [ ] 一貫性のない命名の修正
  - [ ] 分かりやすい名前への変更
  - [ ] 略語の統一

- [ ] 複雑度の削減
  - [ ] 長い関数の分割
  - [ ] ネストの削減
  - [ ] 条件分岐の簡素化

#### 依存関係の整理
- [ ] 未使用の依存関係の削除
- [ ] 依存関係の最新化
- [ ] 脆弱性のある依存関係の更新
- [ ] ライセンスの確認と整理

#### テストカバレッジの向上
- [ ] カバレッジの低い箇所の特定
- [ ] 追加テストの作成
- [ ] テストの品質向上
- [ ] テストの保守性改善

### リリース準備

#### バージョニング戦略
- [ ] セマンティックバージョニングの採用
- [ ] CHANGELOGの作成
- [ ] リリースノートの作成

#### CI/CD強化
- [ ] 自動リリースフローの構築
- [ ] ビルド最適化
- [ ] デプロイメント自動化

#### パッケージング
- [ ] Tauriアプリのインストーラー改善
  - [ ] macOS: .dmg, .app の最適化
  - [ ] Windows: .msi の署名
  - [ ] 自動更新機能の実装

---

## 📈 カバレッジ目標

### 短期目標（Phase 1&2 完了時）✅
- [x] バックエンド: 50% → 70% 達成
- [x] フロントエンド: 24% → 50% 達成

### 中期目標（Phase 3 完了時）
- [ ] バックエンド: 70% → 80%
- [ ] フロントエンド: 50% → 70%
- [ ] E2E: 基本フロー → 全主要フロー

### 長期目標（Phase 4&5 完了時）
- [ ] バックエンド: 80%+
- [ ] フロントエンド: 70%+
- [ ] E2E: 全フロー + エッジケース
- [ ] CI/CD完全自動化
- [ ] カバレッジレポート自動生成

---

## 🔧 開発環境セットアップ

### テスト実行コマンド

#### バックエンド
```bash
# 全テスト実行
cargo test

# 特定のテスト実行
cargo test connection_service

# カバレッジ測定
cargo tarpaulin --out Html

# ウォッチモード
cargo watch -x test
```

#### フロントエンド
```bash
# 全テスト実行
npm run test:run

# ウォッチモード
npm run test

# カバレッジ測定
npm run test:coverage

# 特定のテスト実行
npm run test:run -- src/api/client.test.ts
```

#### E2E
```bash
# E2Eテスト実行
npx playwright test

# UIモード（デバッグ用）
npx playwright test --ui

# 特定のブラウザ
npx playwright test --project=chromium
```

---

## 📝 テスト作成のガイドライン

### バックエンド（Rust）
- `#[cfg(test)]` モジュールを使用
- `#[tokio::test]` で非同期テスト
- Arrange-Act-Assert パターン
- モックには `mockall` クレートを使用
- テスト名は `test_<function>_<scenario>` 形式

### フロントエンド（TypeScript/React）
- `vitest` と `@testing-library/react` を使用
- コンポーネントは `render()` でマウント
- `userEvent` でユーザー操作をシミュレート
- `waitFor()` で非同期処理を待機
- `vi.mock()` でモジュールをモック

### E2E（Playwright）
- Page Objectパターンを使用
- テストは独立して実行可能に
- `test.describe()` でグループ化
- `test.beforeEach()` でセットアップ
- スクリーンショットでデバッグ
