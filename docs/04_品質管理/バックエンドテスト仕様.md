# バックエンド テスト仕様書

## 概要

本仕様書は、TFKosmosバックエンド（Rust/Axum）のテスト仕様を定義します。

### テスト環境

| 項目 | 内容 |
|------|------|
| テストフレームワーク | Rust標準テストフレームワーク |
| 実行コマンド | `cargo test` |
| 詳細出力 | `cargo test -- --nocapture` |
| 特定テスト | `cargo test test_関数名` |

---

## 1. 設定モジュール（config.rs）

**ファイル**: `src/config.rs`

### 1.1 テストケース一覧

| テストID | テストケース | 入力 | 期待結果 |
|----------|-------------|------|----------|
| CFG-001 | デフォルト設定が正しい | `Config::default()` | environment=Development, host="0.0.0.0", port=8000, cors_origins=空 |
| CFG-002 | 開発環境判定が正しい | `environment: Development` | `is_development()`=true, `is_production()`=false |
| CFG-003 | 本番環境判定が正しい | `environment: Production` | `is_production()`=true, `is_development()`=false |
| CFG-004 | バインドアドレスが正しく生成される | `host="127.0.0.1", port=3000` | `bind_address()`="127.0.0.1:3000" |

### 1.2 テストコード

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = Config::default();
        assert_eq!(config.environment, Environment::Development);
        assert_eq!(config.host, "0.0.0.0");
        assert_eq!(config.port, 8000);
        assert!(config.cors_origins.is_empty());
    }

    #[test]
    fn test_is_development() {
        let config = Config {
            environment: Environment::Development,
            ..Default::default()
        };
        assert!(config.is_development());
        assert!(!config.is_production());
    }

    #[test]
    fn test_is_production() {
        let config = Config {
            environment: Environment::Production,
            ..Default::default()
        };
        assert!(config.is_production());
        assert!(!config.is_development());
    }

    #[test]
    fn test_bind_address() {
        let config = Config {
            host: "127.0.0.1".to_string(),
            port: 3000,
            ..Default::default()
        };
        assert_eq!(config.bind_address(), "127.0.0.1:3000");
    }
}
```

---

## 2. APIエラーハンドリング（api/error.rs）

**ファイル**: `src/api/error.rs`

### 2.1 テストケース一覧

| テストID | テストケース | 入力 | 期待結果 |
|----------|-------------|------|----------|
| ERR-001 | Validationエラーのステータスコードとコードが正しい | `ApiError::Validation("Invalid input")` | StatusCode=BAD_REQUEST, code="VALIDATION_ERROR" |
| ERR-002 | NotFoundエラーのステータスコードとコードが正しい | `ApiError::NotFound("Resource not found")` | StatusCode=NOT_FOUND, code="NOT_FOUND" |
| ERR-003 | ExternalServiceエラーに詳細情報が含まれる | `ApiError::ExternalService{service: "AWS", message: "Connection failed"}` | StatusCode=BAD_GATEWAY, details=Some |
| ERR-004 | anyhowエラーからNotFoundへの変換 | `anyhow!("Resource not found")` | `ApiError::NotFound(_)` |
| ERR-005 | anyhowエラーからInternalへの変換 | `anyhow!("Something went wrong")` | `ApiError::Internal(_)` |

### 2.2 テストコード

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validation_error_status_code() {
        let error = ApiError::Validation("Invalid input".to_string());
        assert_eq!(error.status_code(), StatusCode::BAD_REQUEST);
        assert_eq!(error.code(), "VALIDATION_ERROR");
    }

    #[test]
    fn test_not_found_error_status_code() {
        let error = ApiError::NotFound("Resource not found".to_string());
        assert_eq!(error.status_code(), StatusCode::NOT_FOUND);
        assert_eq!(error.code(), "NOT_FOUND");
    }

    #[test]
    fn test_external_service_error_has_details() {
        let error = ApiError::ExternalService {
            service: "AWS".to_string(),
            message: "Connection failed".to_string(),
        };
        assert_eq!(error.status_code(), StatusCode::BAD_GATEWAY);
        assert!(error.details().is_some());
    }

    #[test]
    fn test_anyhow_error_conversion_not_found() {
        let err = anyhow::anyhow!("Resource not found");
        let api_error: ApiError = err.into();
        assert!(matches!(api_error, ApiError::NotFound(_)));
    }

    #[test]
    fn test_anyhow_error_conversion_internal() {
        let err = anyhow::anyhow!("Something went wrong");
        let api_error: ApiError = err.into();
        assert!(matches!(api_error, ApiError::Internal(_)));
    }
}
```

---

## 3. リソースサービス（services/resource_service.rs）

**ファイル**: `src/services/resource_service.rs`

### 3.1 テストケース一覧

| テストID | テストケース | 入力 | 期待結果 |
|----------|-------------|------|----------|
| RS-001 | 文字列フィールドで検索がマッチする | `name: "TestUser"`, 検索語: "testuser" | true |
| RS-002 | ARNフィールドで検索がマッチする | `arn: "arn:aws:iam::123456789012:user/TestUser"`, 検索語: "123456789012" | true |
| RS-003 | 存在しない文字列で検索がマッチしない | 検索語: "nonexistent" | false |
| RS-004 | 大文字小文字を区別しない検索 | `name: "AdminUser"`, 検索語: "adminuser" | true |
| RS-005 | 部分一致検索 | `name: "AdminUser"`, 検索語: "admin" | true |
| RS-006 | ネストしたオブジェクトの検索 | `permissions.action: "s3:GetObject"`, 検索語: "s3:getobject" | true |
| RS-007 | 配列フィールドの検索 | `members: ["user1", "user2", "admin"]`, 検索語: "user1" | true |

### 3.2 テストコード

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_resource_matches_search_string_field() {
        let resource = json!({
            "name": "TestUser",
            "arn": "arn:aws:iam::123456789012:user/TestUser"
        });

        assert!(ResourceService::resource_matches_search(&resource, "testuser"));
        assert!(ResourceService::resource_matches_search(&resource, "123456789012"));
        assert!(!ResourceService::resource_matches_search(&resource, "nonexistent"));
    }

    #[test]
    fn test_resource_matches_search_case_insensitive() {
        let resource = json!({
            "name": "AdminUser"
        });

        assert!(ResourceService::resource_matches_search(&resource, "adminuser"));
        assert!(ResourceService::resource_matches_search(&resource, "admin"));
    }

    #[test]
    fn test_resource_matches_search_nested_object() {
        let resource = json!({
            "name": "TestRole",
            "permissions": {
                "action": "s3:GetObject",
                "resource": "*"
            }
        });

        assert!(ResourceService::resource_matches_search(&resource, "s3:getobject"));
        assert!(ResourceService::resource_matches_search(&resource, "testrole"));
    }

    #[test]
    fn test_resource_matches_search_array_field() {
        let resource = json!({
            "name": "TestGroup",
            "members": ["user1", "user2", "admin"]
        });

        assert!(ResourceService::resource_matches_search(&resource, "user1"));
    }
}
```

---

## 4. 命名規則ジェネレーター（infra/generators/naming.rs）

**ファイル**: `src/infra/generators/naming.rs`

### 4.1 テストケース一覧

#### to_snake_case

| テストID | テストケース | 入力 | 期待結果 |
|----------|-------------|------|----------|
| NM-SC-001 | ハイフンをアンダースコアに変換 | "my-resource-name" | "my_resource_name" |
| NM-SC-002 | ドットをアンダースコアに変換 | "my.resource.name" | "my_resource_name" |
| NM-SC-003 | 大文字を小文字に変換 | "MyResourceName" | "myresourcename" |
| NM-SC-004 | 混合パターンの変換 | "My-Resource.Name" | "my_resource_name" |

#### to_kebab_case

| テストID | テストケース | 入力 | 期待結果 |
|----------|-------------|------|----------|
| NM-KC-001 | アンダースコアをハイフンに変換 | "my_resource_name" | "my-resource-name" |
| NM-KC-002 | ドットをハイフンに変換 | "my.resource.name" | "my-resource-name" |
| NM-KC-003 | 大文字を小文字に変換 | "MyResourceName" | "myresourcename" |
| NM-KC-004 | 混合パターンの変換 | "My_Resource.Name" | "my-resource-name" |

#### apply_naming_convention

| テストID | テストケース | 入力 | 期待結果 |
|----------|-------------|------|----------|
| NM-AN-001 | snake_case適用 | ("my-name", "snake_case") | "my_name" |
| NM-AN-002 | kebab-case適用 | ("my_name", "kebab-case") | "my-name" |

### 4.2 テストコード

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_snake_case_with_hyphen() {
        assert_eq!(NamingGenerator::to_snake_case("my-resource-name"), "my_resource_name");
    }

    #[test]
    fn test_to_snake_case_with_dot() {
        assert_eq!(NamingGenerator::to_snake_case("my.resource.name"), "my_resource_name");
    }

    #[test]
    fn test_to_snake_case_with_uppercase() {
        assert_eq!(NamingGenerator::to_snake_case("MyResourceName"), "myresourcename");
    }

    #[test]
    fn test_to_snake_case_mixed() {
        assert_eq!(NamingGenerator::to_snake_case("My-Resource.Name"), "my_resource_name");
    }

    #[test]
    fn test_to_kebab_case_with_underscore() {
        assert_eq!(NamingGenerator::to_kebab_case("my_resource_name"), "my-resource-name");
    }

    #[test]
    fn test_to_kebab_case_with_dot() {
        assert_eq!(NamingGenerator::to_kebab_case("my.resource.name"), "my-resource-name");
    }

    #[test]
    fn test_to_kebab_case_with_uppercase() {
        assert_eq!(NamingGenerator::to_kebab_case("MyResourceName"), "myresourcename");
    }

    #[test]
    fn test_to_kebab_case_mixed() {
        assert_eq!(NamingGenerator::to_kebab_case("My_Resource.Name"), "my-resource-name");
    }

    #[test]
    fn test_apply_naming_convention_snake_case() {
        assert_eq!(NamingGenerator::apply_naming_convention("my-name", "snake_case"), "my_name");
    }

    #[test]
    fn test_apply_naming_convention_kebab_case() {
        assert_eq!(NamingGenerator::apply_naming_convention("my_name", "kebab-case"), "my-name");
    }
}
```

---

## 5. 未実装テスト（今後の追加予定）

### 5.1 スキャナー（infra/aws/scanner.rs, infra/azure/scanner.rs）

| モジュール | 優先度 | テスト内容 |
|-----------|--------|----------|
| AwsIamScanner | 高 | スキャン実行、フィルタリング、エラーハンドリング |
| AzureScanner | 高 | スキャン実行、フィルタリング、エラーハンドリング |

**モック戦略**: AWS/Azure SDKの呼び出しをモック化

```rust
#[cfg(test)]
mod tests {
    use mockall::predicate::*;

    #[tokio::test]
    async fn test_scan_with_mock_aws() {
        let mut mock_client = MockAwsIamClient::new();
        mock_client
            .expect_list_users()
            .returning(|| Ok(vec![/* mock data */]));

        let scanner = AwsIamScanner::new_with_client(mock_client);
        let result = scanner.scan_users().await;
        assert!(result.is_ok());
    }
}
```

### 5.2 APIルート（api/routes/）

| モジュール | 優先度 | テスト内容 |
|-----------|--------|----------|
| connection.rs | 高 | 接続テストAPI、バリデーション |
| scan.rs | 高 | スキャン開始、ステータス取得 |
| resources.rs | 中 | リソース一覧、フィルタリング |
| generate.rs | 中 | Terraform生成、ダウンロード |
| templates.rs | 低 | テンプレートCRUD |

**統合テスト例**:

```rust
#[cfg(test)]
mod integration_tests {
    use axum::http::StatusCode;
    use axum_test::TestServer;

    #[tokio::test]
    async fn test_health_check() {
        let app = create_app();
        let server = TestServer::new(app).unwrap();

        let response = server.get("/api/health").await;
        assert_eq!(response.status_code(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_scan_validation_error() {
        let app = create_app();
        let server = TestServer::new(app).unwrap();

        let response = server
            .post("/api/scan/aws")
            .json(&serde_json::json!({}))
            .await;

        assert_eq!(response.status_code(), StatusCode::BAD_REQUEST);
    }
}
```

### 5.3 テンプレートマネージャー（infra/templates/manager.rs）

| モジュール | 優先度 | テスト内容 |
|-----------|--------|----------|
| TemplateManager | 中 | テンプレート読み込み、レンダリング、変数置換 |

### 5.4 Terraformジェネレーター（infra/generators/terraform.rs）

| モジュール | 優先度 | テスト内容 |
|-----------|--------|----------|
| TerraformGenerator | 中 | コード生成、importスクリプト生成 |

---

## 6. テスト実行手順

### 6.1 全テスト実行

```bash
cd backend
cargo test
```

### 6.2 特定テストの実行

```bash
cargo test test_default_config
cargo test test_validation_error
```

### 6.3 詳細出力付き実行

```bash
cargo test -- --nocapture
```

### 6.4 特定モジュールのテスト

```bash
cargo test --package tfkosmos config::tests
cargo test --package tfkosmos api::error::tests
```

---

## 7. テストコード記述規約

### 7.1 命名規則

- テスト関数: `test_{機能}_{条件}_{期待結果}` または `test_{機能}_{what_it_does}`
- テストモジュール: `#[cfg(test)] mod tests { ... }`

### 7.2 構造

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_function_name_describes_what_it_tests() {
        // Arrange
        let input = ...;

        // Act
        let result = function_under_test(input);

        // Assert
        assert_eq!(result, expected);
    }
}
```

### 7.3 非同期テスト

```rust
#[tokio::test]
async fn test_async_function() {
    let result = async_function().await;
    assert!(result.is_ok());
}
```

### 7.4 禁止事項

- 意味のないアサーション（例: `assert!(true)`）
- テストを通すためだけのハードコーディング
- 外部サービスへの実際の接続（モックを使用すること）
- テスト間の依存関係
- 本番コードに `if cfg!(test)` のようなテスト用条件分岐を入れること
- テスト用の特別な値（マジックナンバー）を本番コードに埋め込むこと

---

## 8. テストの独立性と再現性

### 8.1 テストの独立性

- 各テストは他のテストに依存しないこと（実行順序に依存しない）
- テストは何度実行しても同じ結果になること（冪等性）
- テスト間で共有状態を持たないこと（グローバル変数やstaticの変更を避ける）

### 8.2 外部依存のモック化

- 外部サービス（AWS/Azure API、ファイルシステム）への依存は適切にモック化すること
- 日時やランダム値に依存するテストは、値を固定して再現性を確保すること

```rust
// 日時のモック例（chrono使用時）
use chrono::{TimeZone, Utc};

fn test_with_fixed_time() {
    let fixed_time = Utc.with_ymd_and_hms(2024, 1, 1, 0, 0, 0).unwrap();
    // fixed_timeを使用してテスト
}
```

---

## 9. テストデータの管理

### 9.1 テストデータの作成と管理

- テストデータはテスト内で明示的に作成すること
- 大量のテストデータが必要な場合は、ヘルパー関数やビルダーパターンを使用すること

```rust
// ビルダーパターンの例
#[cfg(test)]
mod test_helpers {
    use super::*;

    pub struct UserBuilder {
        name: String,
        email: String,
    }

    impl UserBuilder {
        pub fn new() -> Self {
            Self {
                name: "Test User".to_string(),
                email: "test@example.com".to_string(),
            }
        }

        pub fn name(mut self, name: &str) -> Self {
            self.name = name.to_string();
            self
        }

        pub fn build(self) -> User {
            User {
                name: self.name,
                email: self.email,
            }
        }
    }
}
```

### 9.2 一時ファイルの管理

```rust
use tempfile::TempDir;

#[test]
fn test_file_operations() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("test.txt");

    // テスト実行
    // temp_dirはスコープ終了時に自動クリーンアップ
}
```

---

## 10. モックとスタブの適切な使用

### 10.1 モックの使用原則

- モックは外部依存（API呼び出し、DB操作）に対してのみ使用すること
- 内部実装の詳細をモックしすぎないこと（リファクタリング耐性が下がる）
- モックの振る舞いが本番環境と乖離しないよう注意すること

### 10.2 mockallクレートの使用例

```rust
use mockall::{automock, predicate::*};

#[automock]
trait AwsClient {
    async fn list_users(&self) -> Result<Vec<User>, Error>;
}

#[tokio::test]
async fn test_scan_users() {
    let mut mock = MockAwsClient::new();
    mock.expect_list_users()
        .times(1)
        .returning(|| Ok(vec![User::new("test")]));

    let scanner = Scanner::new(mock);
    let result = scanner.scan().await;
    assert!(result.is_ok());
}
```

### 10.3 トレイトを使った依存性注入

```rust
// 本番コード
trait CloudScanner: Send + Sync {
    async fn scan(&self) -> Result<Resources, Error>;
}

struct AwsScanner { /* ... */ }
impl CloudScanner for AwsScanner { /* ... */ }

// テスト用モック
#[cfg(test)]
struct MockScanner;

#[cfg(test)]
impl CloudScanner for MockScanner {
    async fn scan(&self) -> Result<Resources, Error> {
        Ok(Resources::default())
    }
}
```

---

## 11. 非同期処理のテスト

### 11.1 基本原則

- 非同期テストでは `#[tokio::test]` マクロを使用すること
- タイムアウトは明示的に設定し、テストが無限に待機しないようにすること
- Result型のErr ケースも必ずテストすること

### 11.2 タイムアウトの設定

```rust
use tokio::time::{timeout, Duration};

#[tokio::test]
async fn test_with_timeout() {
    let result = timeout(Duration::from_secs(5), async_operation()).await;
    assert!(result.is_ok(), "Operation timed out");
}
```

### 11.3 エラーケースのテスト

```rust
#[tokio::test]
async fn test_api_error_handling() {
    let mut mock = MockAwsClient::new();
    mock.expect_list_users()
        .returning(|| Err(Error::new("Connection failed")));

    let scanner = Scanner::new(mock);
    let result = scanner.scan().await;

    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Connection failed"));
}
```

---

## 12. テストの保守性

### 12.1 可読性

- テストコードもプロダクションコードと同様に可読性を重視すること
- 過度なDRYよりも、各テストの意図が明確に分かることを優先すること

### 12.2 アサーションメッセージ

- テストが失敗した際に、原因が特定しやすいメッセージを記述すること

```rust
assert_eq!(
    result.status_code(),
    StatusCode::BAD_REQUEST,
    "バリデーションエラー時はBAD_REQUESTを返すべき"
);
```

### 12.3 AAA（Arrange-Act-Assert）パターン

すべてのテストは以下の構造で記述すること：

```rust
#[test]
fn test_user_creation() {
    // Arrange: テストの準備
    let name = "Test User";
    let email = "test@example.com";

    // Act: テスト対象の操作を実行
    let user = User::new(name, email);

    // Assert: 期待する結果を検証
    assert_eq!(user.name(), name);
    assert_eq!(user.email(), email);
}
```

---

## 13. テスト実装の原則

### 13.1 Red-Green-Refactor

- テストが失敗する状態から始めること
- 最小限のコードでテストを通す
- コードをリファクタリング

### 13.2 境界値と異常系

- 境界値、異常系、エラーケースも必ずテストすること
- カバレッジだけでなく、実際の品質を重視すること

```rust
#[cfg(test)]
mod validation_tests {
    use super::*;

    #[test]
    fn test_empty_input_returns_error() { /* ... */ }

    #[test]
    fn test_max_length_input_succeeds() { /* ... */ }

    #[test]
    fn test_exceeds_max_length_returns_error() { /* ... */ }

    #[test]
    fn test_invalid_characters_returns_error() { /* ... */ }
}
```

### 13.3 実装前の確認

- 機能の仕様を正しく理解してからテストを書くこと
- 不明な点があれば、仮の実装ではなく、ユーザーに確認すること

---

## 14. プロパティベーステスト（オプション）

### 14.1 proptest クレートの使用例

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_snake_case_always_lowercase(s in "[a-zA-Z0-9_-]+") {
        let result = to_snake_case(&s);
        assert!(result.chars().all(|c| c.is_lowercase() || c == '_'));
    }
}
```

### 14.2 適用シーン

- 変換関数（命名規則変換など）
- パーサー
- シリアライゼーション/デシリアライゼーション
