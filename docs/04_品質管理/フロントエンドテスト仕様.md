# フロントエンド テスト仕様書

## 概要

本仕様書は、TFKosmosフロントエンド（React/TypeScript）のテスト仕様を定義します。

### テスト環境

| 項目 | 内容 |
|------|------|
| テストフレームワーク | Vitest 3.x |
| UIテストライブラリ | React Testing Library |
| 実行コマンド | `npm run test` |
| カバレッジ | `npm run test:coverage` |

---

## 1. 共通コンポーネント（components/common）

### 1.1 LoadingSpinner

**ファイル**: `src/components/common/LoadingSpinner.test.tsx`

| テストID | テストケース | 入力 | 期待結果 |
|----------|-------------|------|----------|
| LS-001 | 正常にレンダリングされる | コンポーネントをレンダリング | container.firstChildが存在する |
| LS-002 | スピナー要素が存在する | コンポーネントをレンダリング | div > div要素が存在する |
| LS-003 | アニメーション用style要素が存在する | コンポーネントをレンダリング | style要素に`@keyframes spin`が含まれる |

---

### 1.2 ErrorMessage

**ファイル**: `src/components/common/ErrorMessage.test.tsx`

| テストID | テストケース | 入力 | 期待結果 |
|----------|-------------|------|----------|
| EM-001 | メッセージを表示する | `message="エラーが発生しました"` | "エラーが発生しました"が画面に表示される |
| EM-002 | 複数行のメッセージを正しく表示する | 改行を含むメッセージ | 各行が個別に表示される |
| EM-003 | onCloseが未指定の場合、閉じるボタンを表示しない | `onClose`なし | ボタン要素が存在しない |
| EM-004 | onCloseが指定されている場合、閉じるボタンをクリックで呼び出す | `onClose={handleClose}` | ボタンクリック時にhandleCloseが1回呼ばれる |

---

### 1.3 SuccessMessage

**ファイル**: `src/components/common/SuccessMessage.test.tsx`

| テストID | テストケース | 入力 | 期待結果 |
|----------|-------------|------|----------|
| SM-001 | メッセージを表示する | `message="操作が成功しました"` | "操作が成功しました"が画面に表示される |
| SM-002 | onCloseが未指定の場合、閉じるボタンを表示しない | `onClose`なし | ボタン要素が存在しない |
| SM-003 | onCloseが指定されている場合、閉じるボタンをクリックで呼び出す | `onClose={handleClose}` | ボタンクリック時にhandleCloseが1回呼ばれる |

---

## 2. スキャンコンポーネント（components/scan）

### 2.1 ScanTargetSelector

**ファイル**: `src/components/scan/ScanTargetSelector.test.tsx`

#### AWSプロバイダーの場合

| テストID | テストケース | 入力 | 期待結果 |
|----------|-------------|------|----------|
| STS-AWS-001 | AWS用のスキャン対象を全て表示する | `provider="aws"` | Users, Groups, Roles, Policies, Attachmentsが表示される |
| STS-AWS-002 | チェックボックスの状態が正しく反映される | `scanTargets={users: true, groups: false, ...}` | チェック状態が入力値と一致する |
| STS-AWS-003 | チェックボックスをクリックするとtoggleTargetが呼ばれる | Groupsチェックボックスをクリック | `toggleTarget('groups')`が呼ばれる |
| STS-AWS-004 | IAM親チェックボックスが表示される | `provider="aws"` | IAMラベルが表示される |
| STS-AWS-005 | IAM親チェックボックスをクリックするとtoggleAllTargetsが呼ばれる | 一部チェック状態でIAMをクリック | `toggleAllTargets(false)`が呼ばれる |
| STS-AWS-006 | 全ての子がチェックされている場合、IAM親チェックボックスがチェック状態になる | 全項目チェック済み | IAMチェックボックスがchecked |
| STS-AWS-007 | 全ての子がチェック解除されている場合、IAMをクリックすると全部チェックされる | 全項目未チェック | `toggleAllTargets(true)`が呼ばれる |

#### Azureプロバイダーの場合

| テストID | テストケース | 入力 | 期待結果 |
|----------|-------------|------|----------|
| STS-AZ-001 | Azure用のスキャン対象を全て表示する | `provider="azure"` | Role Definitions, Role Assignmentsが表示される |
| STS-AZ-002 | AWS用のスキャン対象は表示されない | `provider="azure"` | Users, Policiesが存在しない |
| STS-AZ-003 | チェックボックスの状態が正しく反映される | `scanTargets={role_definitions: true, role_assignments: false}` | チェック状態が入力値と一致する |

---

### 2.2 ScanProgressBar

**ファイル**: `src/components/scan/ScanProgressBar.test.tsx`

| テストID | テストケース | 入力 | 期待結果 |
|----------|-------------|------|----------|
| SPB-001 | 進捗率を表示する | `progress={50}` | "50%"が表示される |
| SPB-002 | 進捗率が10%以下の場合、パーセンテージ表示しない | `progress={5}` | "5%"が表示されない |
| SPB-003 | メッセージを表示する | `message="ユーザーをスキャン中..."` | "ユーザーをスキャン中..."が表示される |
| SPB-004 | メッセージが空の場合、デフォルトメッセージを表示する | `message=""` | "スキャン中..."が表示される |
| SPB-005 | 進捗が100%未満の場合、ローディングスピナーを表示する | `progress={80}` | スピナーコンテナが存在する |
| SPB-006 | 進捗が100%の場合、ローディングスピナーを表示しない | `progress={100}` | スピナーコンテナが存在しない |
| SPB-007 | プログレスバーの幅が進捗率に応じて設定される | `progress={75}` | `width: 75%`のスタイルが適用される |

---

## 3. テストユーティリティ

### 3.1 カスタムレンダラー

**ファイル**: `src/test/utils.tsx`

```typescript
// BrowserRouterでラップしたカスタムrender関数を提供
export { customRender as render };
```

### 3.2 セットアップ

**ファイル**: `src/test/setup.ts`

- `@testing-library/jest-dom`のインポート
- 各テスト後のクリーンアップ
- localStorageのモック

---

## 4. 未実装テスト（今後の追加予定）

### 4.1 ページコンポーネント

| コンポーネント | 優先度 | テスト内容 |
|--------------|--------|----------|
| ConnectionPage | 高 | 接続テスト、認証情報入力バリデーション |
| ScanPage | 高 | スキャン実行、結果表示 |
| ResourcesPage | 中 | リソース一覧表示、フィルタリング |
| GeneratePage | 中 | Terraform生成、ダウンロード |
| TemplatePage | 低 | テンプレート編集、保存 |

### 4.2 APIクライアント

| モジュール | 優先度 | テスト内容 |
|-----------|--------|----------|
| scan.ts | 高 | スキャンAPI呼び出し、エラーハンドリング |
| resources.ts | 中 | リソース取得、フィルタリング |
| generate.ts | 中 | Terraform生成API |

---

## 5. テスト実行手順

### 5.1 全テスト実行

```bash
cd frontend
npm run test
```

### 5.2 特定ファイルのテスト

```bash
npm run test:run -- src/components/scan/ScanTargetSelector.test.tsx
```

### 5.3 ウォッチモード

```bash
npm run test:watch
```

### 5.4 カバレッジ取得

```bash
npm run test:coverage
```

---

## 6. テストコード記述規約

### 6.1 命名規則

- テストファイル: `{ComponentName}.test.tsx`
- describe: コンポーネント名または機能グループ
- it: 日本語で具体的な動作を記述

### 6.2 構造

```typescript
describe('ComponentName', () => {
  describe('特定の条件下', () => {
    it('期待される動作を記述', () => {
      // Arrange
      const props = { ... };

      // Act
      render(<Component {...props} />);

      // Assert
      expect(...).toBeInTheDocument();
    });
  });
});
```

### 6.3 禁止事項

- `expect(true).toBe(true)` のような意味のないアサーション
- テストを通すためだけのハードコーディング
- 本番コードへのテスト用条件分岐の追加（例: `if(testMode)`）
- テスト用の特別な値（マジックナンバー）を本番コードに埋め込むこと

---

## 7. テストの独立性と再現性

### 7.1 テストの独立性

- 各テストは他のテストに依存しないこと（実行順序に依存しない）
- テストは何度実行しても同じ結果になること（冪等性）
- テスト間で共有状態を持たないこと（グローバル変数の変更を避ける）

### 7.2 外部依存のモック化

- 外部サービス（API、データベース、ファイルシステム）への依存は適切にモック化すること
- 日時やランダム値に依存するテストは、値を固定して再現性を確保すること

```typescript
// 日時のモック例
vi.useFakeTimers();
vi.setSystemTime(new Date('2024-01-01T00:00:00Z'));

// テスト後にリストア
vi.useRealTimers();
```

---

## 8. テストデータの管理

### 8.1 テストデータの作成と管理

- テストデータはテスト内で明示的に作成し、テスト後にクリーンアップすること
- 大量のテストデータが必要な場合は、ファクトリー関数やビルダーパターンを使用すること

```typescript
// ファクトリー関数の例
const createMockUser = (overrides = {}) => ({
  id: 'user-1',
  name: 'Test User',
  email: 'test@example.com',
  ...overrides,
});
```

### 8.2 テスト後のクリーンアップ

```typescript
afterEach(() => {
  cleanup();
  vi.clearAllMocks();
  localStorage.clear();
});
```

---

## 9. モックとスタブの適切な使用

### 9.1 モックの使用原則

- モックは外部依存（API呼び出し、DB操作）に対してのみ使用すること
- 内部実装の詳細をモックしすぎないこと（リファクタリング耐性が下がる）
- モックの振る舞いが本番環境と乖離しないよう注意すること

### 9.2 スパイの使用

- スパイを使用する場合は、テスト後に必ずリストアすること

```typescript
const spy = vi.spyOn(module, 'functionName');

afterEach(() => {
  spy.mockRestore();
});
```

### 9.3 APIモックの例

```typescript
import { vi } from 'vitest';
import axios from 'axios';

vi.mock('axios');

describe('API呼び出しのテスト', () => {
  it('正常にデータを取得する', async () => {
    const mockData = { users: [] };
    vi.mocked(axios.get).mockResolvedValue({ data: mockData });

    const result = await fetchUsers();
    expect(result).toEqual(mockData);
  });
});
```

---

## 10. 非同期処理のテスト

### 10.1 基本原則

- 非同期テストでは必ず適切に `await` すること
- タイムアウトは明示的に設定し、テストが無限に待機しないようにすること
- Promise の reject ケースも必ずテストすること

### 10.2 タイマーモック

```typescript
import { vi } from 'vitest';

describe('タイマーを使用するコンポーネント', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('3秒後にメッセージが表示される', async () => {
    render(<DelayedMessage />);

    vi.advanceTimersByTime(3000);

    expect(screen.getByText('メッセージ')).toBeInTheDocument();
  });
});
```

### 10.3 非同期エラーハンドリング

```typescript
it('APIエラー時にエラーメッセージを表示する', async () => {
  vi.mocked(axios.get).mockRejectedValue(new Error('Network Error'));

  render(<DataComponent />);

  await waitFor(() => {
    expect(screen.getByText('エラーが発生しました')).toBeInTheDocument();
  });
});
```

---

## 11. テストの保守性

### 11.1 可読性

- テストコードもプロダクションコードと同様に可読性を重視すること
- 過度なDRYよりも、各テストの意図が明確に分かることを優先すること

### 11.2 アサーションメッセージ

- テストが失敗した際に、原因が特定しやすいアサーションメッセージを記述すること

```typescript
expect(result).toBe(expected, 'ユーザー名が正しく設定されていません');
```

### 11.3 AAA（Arrange-Act-Assert）パターン

すべてのテストは以下の構造で記述すること：

```typescript
it('ボタンクリックでカウントが増加する', () => {
  // Arrange: テストの準備
  const { getByRole } = render(<Counter initialCount={0} />);

  // Act: テスト対象の操作を実行
  fireEvent.click(getByRole('button', { name: '増加' }));

  // Assert: 期待する結果を検証
  expect(getByRole('heading')).toHaveTextContent('1');
});
```

---

## 12. スナップショットテストの注意点

### 12.1 使用時の注意

- スナップショットの差分は必ず目視で確認してから更新すること
- 意図しない変更を安易に `--update` で上書きしないこと
- 大きすぎるスナップショットは避け、必要な部分のみをテストすること

### 12.2 推奨される使用例

```typescript
// 小さなコンポーネントのスナップショット
it('アイコンが正しくレンダリングされる', () => {
  const { container } = render(<Icon name="check" />);
  expect(container.firstChild).toMatchSnapshot();
});
```

### 12.3 避けるべき使用例

```typescript
// 大きなページコンポーネント全体のスナップショットは避ける
// 代わりに個別の要素をテストする
```

---

## 13. テスト実装の原則

### 13.1 Red-Green-Refactor

- テストが失敗する状態から始めること
- 最小限のコードでテストを通す
- コードをリファクタリング

### 13.2 境界値と異常系

- 境界値、異常系、エラーケースも必ずテストすること
- カバレッジだけでなく、実際の品質を重視すること

```typescript
describe('入力バリデーション', () => {
  it('空文字列でエラーを表示する', () => { /* ... */ });
  it('最大文字数を超えた場合エラーを表示する', () => { /* ... */ });
  it('許可されていない文字が含まれる場合エラーを表示する', () => { /* ... */ });
});
```

### 13.3 実装前の確認

- 機能の仕様を正しく理解してからテストを書くこと
- 不明な点があれば、仮の実装ではなく、ユーザーに確認すること
